{"ast":null,"code":"// ... existing imports ...\n\nexport const AuthProvider = ({\n  children\n}) => {\n  // ... existing state ...\n\n  // Initialize axios instance with interceptors\n  const axiosInstance = axios.create({\n    baseURL: API_URL,\n    withCredentials: true,\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n\n  // Add request interceptor\n  axiosInstance.interceptors.request.use(config => {\n    const token = localStorage.getItem(\"accessToken\");\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    return config;\n  }, error => {\n    return Promise.reject(error);\n  });\n\n  // Add response interceptor\n  axiosInstance.interceptors.response.use(response => response, async error => {\n    var _error$response;\n    const originalRequest = error.config;\n\n    // If error is not 401 or request has already been retried, reject\n    if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) !== 401 || originalRequest._retry) {\n      return Promise.reject(error);\n    }\n    originalRequest._retry = true;\n    try {\n      // Try to refresh the token\n      const response = await axios.post(`${API_URL}/api/auth/refresh-token`, {}, {\n        withCredentials: true\n      });\n      const {\n        accessToken: newAccessToken\n      } = response.data.data;\n      localStorage.setItem(\"accessToken\", newAccessToken);\n      axiosInstance.defaults.headers.common[\"Authorization\"] = `Bearer ${newAccessToken}`;\n      return axiosInstance(originalRequest);\n    } catch (refreshError) {\n      // If refresh fails, logout user\n      logout();\n      return Promise.reject(refreshError);\n    }\n  });\n\n  // ... rest of the context code ...\n};\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["AuthProvider","children","axiosInstance","axios","create","baseURL","API_URL","withCredentials","headers","interceptors","request","use","config","token","localStorage","getItem","Authorization","error","Promise","reject","response","_error$response","originalRequest","status","_retry","post","accessToken","newAccessToken","data","setItem","defaults","common","refreshError","logout","_c","$RefreshReg$"],"sources":["/home/muaze/mini-project/frontend/src/context/AuthContext.js"],"sourcesContent":["// ... existing imports ...\n\nexport const AuthProvider = ({ children }) => {\n  // ... existing state ...\n\n  // Initialize axios instance with interceptors\n  const axiosInstance = axios.create({\n    baseURL: API_URL,\n    withCredentials: true,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  })\n\n  // Add request interceptor\n  axiosInstance.interceptors.request.use(\n    (config) => {\n      const token = localStorage.getItem(\"accessToken\")\n      if (token) {\n        config.headers.Authorization = `Bearer ${token}`\n      }\n      return config\n    },\n    (error) => {\n      return Promise.reject(error)\n    },\n  )\n\n  // Add response interceptor\n  axiosInstance.interceptors.response.use(\n    (response) => response,\n    async (error) => {\n      const originalRequest = error.config\n\n      // If error is not 401 or request has already been retried, reject\n      if (error.response?.status !== 401 || originalRequest._retry) {\n        return Promise.reject(error)\n      }\n\n      originalRequest._retry = true\n\n      try {\n        // Try to refresh the token\n        const response = await axios.post(\n          `${API_URL}/api/auth/refresh-token`,\n          {},\n          { withCredentials: true },\n        )\n\n        const { accessToken: newAccessToken } = response.data.data\n\n        localStorage.setItem(\"accessToken\", newAccessToken)\n        axiosInstance.defaults.headers.common[\"Authorization\"] = `Bearer ${newAccessToken}`\n\n        return axiosInstance(originalRequest)\n      } catch (refreshError) {\n        // If refresh fails, logout user\n        logout()\n        return Promise.reject(refreshError)\n      }\n    },\n  )\n\n  // ... rest of the context code ...\n}"],"mappings":"AAAA;;AAEA,OAAO,MAAMA,YAAY,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAC5C;;EAEA;EACA,MAAMC,aAAa,GAAGC,KAAK,CAACC,MAAM,CAAC;IACjCC,OAAO,EAAEC,OAAO;IAChBC,eAAe,EAAE,IAAI;IACrBC,OAAO,EAAE;MACP,cAAc,EAAE;IAClB;EACF,CAAC,CAAC;;EAEF;EACAN,aAAa,CAACO,YAAY,CAACC,OAAO,CAACC,GAAG,CACnCC,MAAM,IAAK;IACV,MAAMC,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,aAAa,CAAC;IACjD,IAAIF,KAAK,EAAE;MACTD,MAAM,CAACJ,OAAO,CAACQ,aAAa,GAAG,UAAUH,KAAK,EAAE;IAClD;IACA,OAAOD,MAAM;EACf,CAAC,EACAK,KAAK,IAAK;IACT,OAAOC,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;EAC9B,CACF,CAAC;;EAED;EACAf,aAAa,CAACO,YAAY,CAACW,QAAQ,CAACT,GAAG,CACpCS,QAAQ,IAAKA,QAAQ,EACtB,MAAOH,KAAK,IAAK;IAAA,IAAAI,eAAA;IACf,MAAMC,eAAe,GAAGL,KAAK,CAACL,MAAM;;IAEpC;IACA,IAAI,EAAAS,eAAA,GAAAJ,KAAK,CAACG,QAAQ,cAAAC,eAAA,uBAAdA,eAAA,CAAgBE,MAAM,MAAK,GAAG,IAAID,eAAe,CAACE,MAAM,EAAE;MAC5D,OAAON,OAAO,CAACC,MAAM,CAACF,KAAK,CAAC;IAC9B;IAEAK,eAAe,CAACE,MAAM,GAAG,IAAI;IAE7B,IAAI;MACF;MACA,MAAMJ,QAAQ,GAAG,MAAMjB,KAAK,CAACsB,IAAI,CAC/B,GAAGnB,OAAO,yBAAyB,EACnC,CAAC,CAAC,EACF;QAAEC,eAAe,EAAE;MAAK,CAC1B,CAAC;MAED,MAAM;QAAEmB,WAAW,EAAEC;MAAe,CAAC,GAAGP,QAAQ,CAACQ,IAAI,CAACA,IAAI;MAE1Dd,YAAY,CAACe,OAAO,CAAC,aAAa,EAAEF,cAAc,CAAC;MACnDzB,aAAa,CAAC4B,QAAQ,CAACtB,OAAO,CAACuB,MAAM,CAAC,eAAe,CAAC,GAAG,UAAUJ,cAAc,EAAE;MAEnF,OAAOzB,aAAa,CAACoB,eAAe,CAAC;IACvC,CAAC,CAAC,OAAOU,YAAY,EAAE;MACrB;MACAC,MAAM,CAAC,CAAC;MACR,OAAOf,OAAO,CAACC,MAAM,CAACa,YAAY,CAAC;IACrC;EACF,CACF,CAAC;;EAED;AACF,CAAC;AAAAE,EAAA,GA9DYlC,YAAY;AAAA,IAAAkC,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}